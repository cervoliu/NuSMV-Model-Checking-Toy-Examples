----------------------------------------------------------------------------------------
-- BUTTON Module
----------------------------------------------------------------------------------------
MODULE Button(reset)
  VAR 
    on : boolean;
  ASSIGN
    init(on) := FALSE;
    next(on) := case 
        reset : FALSE;
        on  & !reset : TRUE;
        !on & !reset : {FALSE, TRUE};
    esac;
----------------------------------------------------------------------------------------
-- CABIN MODULE
----------------------------------------------------------------------------------------
MODULE Cabin(move, stop)
  VAR
    -- floor : 1..5;
    dir : -1..1;
    door : {open, closed};
    pos : 0..20;
    f1 : Button(resetf1);
    f2 : Button(resetf2);
    f3 : Button(resetf3);
    f4 : Button(resetf4);
    f5 : Button(resetf5);
  DEFINE
    P1 := 0;
    P2 := 5;
    P3 := 10;
    P4 := 15;
    P5 := 20;
    floor_at_1 := pos = P1;
    floor_at_2 := pos = P2;
    floor_at_3 := pos = P3;
    floor_at_4 := pos = P4;
    floor_at_5 := pos = P5;
    resetf1 := floor_at_1 & door = open;
    resetf2 := floor_at_2 & door = open;
    resetf3 := floor_at_3 & door = open;
    resetf4 := floor_at_4 & door = open;
    resetf5 := floor_at_5 & door = open;
    inner_stop :=  f1.on & floor_at_1 | 
                   f2.on & floor_at_2 | 
                   f3.on & floor_at_3 |
                   f4.on & floor_at_4 | 
                   f5.on & floor_at_5;
    inreq_highest := case
      f5.on : P5;
      f4.on : P4;
      f3.on : P3;
      f2.on : P2;
      f1.on : P1;
      TRUE : P1;
    esac;
    inreq_lowest := case
      f1.on : P1;
      f2.on : P2;
      f3.on : P3;
      f4.on : P4;
      f5.on : P5;
      TRUE : P5;
    esac;
  ASSIGN
    -- initialization
    init(dir) := 0;
    --init(floor) := 1;
    init(door) := closed;
    init(pos) := 0;

    -- transition
    next(dir) := case
      stop : dir;
      move = 1 : 1;
      move = -1 : -1;
      TRUE : 0;
    esac;
    
    next(pos) := case
        stop : pos;
        pos < P5 & move = 1 : pos + 1;
        pos > P1 & move = -1 : pos - 1;
        TRUE : pos;
    esac;

    --next(floor) := case
    --  stop : floor;
    --  floor < 5 & move = 1 : floor + 1;
    --  floor > 1 & move = -1 : floor - 1;
    --  TRUE : floor;
    --esac;

    next(door) := case
      stop : open;
      TRUE : closed;
    esac;
----------------------------------------------------------------------------------------
-- CONTROLLER MODULE
----------------------------------------------------------------------------------------
MODULE Controller(l1, l2, l3)
  VAR
    up1 : Button(reset_up1);
    up2 : Button(reset_up2);
    up3 : Button(reset_up3);
    up4 : Button(reset_up4);

    dn5 : Button(reset_dn5);
    dn4 : Button(reset_dn4);
    dn3 : Button(reset_dn3);
    dn2 : Button(reset_dn2);

  DEFINE
    reset_up1 := l1.floor_at_1 & l1_stop | l2.floor_at_1 & l2_stop | l3.floor_at_1 & l3_stop;
    reset_up2 := l1.floor_at_2 & l1_stop | l2.floor_at_2 & l2_stop | l3.floor_at_2 & l3_stop;
    reset_up3 := l1.floor_at_3 & l1_stop | l2.floor_at_3 & l2_stop | l3.floor_at_3 & l3_stop;
    reset_up4 := l1.floor_at_4 & l1_stop | l2.floor_at_4 & l2_stop | l3.floor_at_4 & l3_stop;

    reset_dn5 := l1.floor_at_5 & l1_stop | l2.floor_at_5 & l2_stop | l3.floor_at_5 & l3_stop;
    reset_dn4 := l1.floor_at_4 & l1_stop | l2.floor_at_4 & l2_stop | l3.floor_at_4 & l3_stop;
    reset_dn3 := l1.floor_at_3 & l1_stop | l2.floor_at_3 & l2_stop | l3.floor_at_3 & l3_stop;
    reset_dn2 := l1.floor_at_2 & l1_stop | l2.floor_at_2 & l2_stop | l3.floor_at_2 & l3_stop;

    outreq_highest := case
      dn5.on          : l1.P5;
      up4.on | dn4.on : l1.P4;
      up3.on | dn3.on : l1.P3;
      up2.on | dn2.on : l1.P2;
      up1.on          : l1.P1;
      TRUE            : l1.P1;
    esac;

    outreq_lowest := case
      up1.on          : l1.P1;
      up2.on | dn2.on : l1.P2;
      up3.on | dn3.on : l1.P3;
      up4.on | dn4.on : l1.P4;
      dn5.on          : l1.P5;
      TRUE            : l1.P5;
    esac;

    l1_req_highest := l1.inreq_highest > outreq_highest ? l1.inreq_highest : outreq_highest;
    l1_req_lowest := l1.inreq_lowest < outreq_lowest ? l1.inreq_lowest : outreq_lowest;

    l2_req_highest := l2.inreq_highest > outreq_highest ? l2.inreq_highest : outreq_highest;
    l2_req_lowest := l2.inreq_lowest < outreq_lowest ? l2.inreq_lowest : outreq_lowest;

    l3_req_highest := l3.inreq_highest > outreq_highest ? l3.inreq_highest : outreq_highest;
    l3_req_lowest := l3.inreq_lowest < outreq_lowest ? l3.inreq_lowest : outreq_lowest;

    -- move signals

    l1_move := case
      l1.dir >= 0 : l1_req_highest > l1.pos ? 1 : l1_req_lowest < l1.pos ? -1 : 0;
      l1.dir < 0  : l1_req_lowest < l1.pos ? -1 : l1_req_highest > l1.pos ? 1 : 0;
    esac;

    l2_move := case
      l2.dir >= 0 : l2_req_highest > l2.pos ? 1 : l2_req_lowest < l2.pos ? -1 : 0;
      l2.dir < 0  : l2_req_lowest < l2.pos ? -1 : l2_req_highest > l2.pos ? 1 : 0;
    esac;

    l3_move := case
      l3.dir >= 0 : l3_req_highest > l3.pos ? 1 : l3_req_lowest < l3.pos ? -1 : 0;
      l3.dir < 0  : l3_req_lowest < l3.pos ? -1 : l3_req_highest > l3.pos ? 1 : 0;
    esac;

    -- stop signals

    l1_outer_stop := case
      l1.pos = l1_req_highest | l1.pos = l1_req_lowest : TRUE;
      l1_move = 1 : (up1.on & l1.floor_at_1 | 
                     up2.on & l1.floor_at_2 |
                     up3.on & l1.floor_at_3 | 
                     up4.on & l1.floor_at_4);
      l1_move = -1 : (dn5.on & l1.floor_at_5 | 
                      dn4.on & l1.floor_at_4 |
                      dn3.on & l1.floor_at_3 | 
                      dn2.on & l1.floor_at_2);
      TRUE : FALSE;
    esac;

    l1_stop := l1.inner_stop | l1_outer_stop;

    l2_outer_stop := case
      l2.pos = l2_req_highest | l2.pos = l2_req_lowest : TRUE;
      l2_move = 1 : (up1.on & l2.floor_at_1 | 
                     up2.on & l2.floor_at_2 |
                     up3.on & l2.floor_at_3 | 
                     up4.on & l2.floor_at_4);
      l2_move = -1 : (dn5.on & l2.floor_at_5 | 
                      dn4.on & l2.floor_at_4 |
                      dn3.on & l2.floor_at_3 | 
                      dn2.on & l2.floor_at_2);
      TRUE : FALSE;
    esac;

    l2_stop := l2.inner_stop | l2_outer_stop;

    l3_outer_stop := case
      l3.pos = l3_req_highest | l3.pos = l3_req_lowest : TRUE;
      l3_move = 1 : (up1.on & l3.floor_at_1 | 
                     up2.on & l3.floor_at_2 |
                     up3.on & l3.floor_at_3 | 
                     up4.on & l3.floor_at_4);
      l3_move = -1 : (dn5.on & l3.floor_at_5 | 
                      dn4.on & l3.floor_at_4 |
                      dn3.on & l3.floor_at_3 | 
                      dn2.on & l3.floor_at_2);
      TRUE : FALSE;
    esac;

    l3_stop := l3.inner_stop | l3_outer_stop;

----------------------------------------------------------------------------------------
-- MAIN MODULE
----------------------------------------------------------------------------------------
MODULE main
  VAR
    c : Controller(lift1, lift2, lift3);
    lift1 : Cabin(c.l1_move, c.l1_stop);
    lift2 : Cabin(c.l2_move, c.l2_stop);
    lift3 : Cabin(c.l3_move, c.l3_stop);
----------------------------------------------------------------------------------------
-- SPEC
----------------------------------------------------------------------------------------

-- Liveness
LTLSPEC G (c.l1_move = 1 -> F c.l1_move != 1);
LTLSPEC G (c.l1_move = -1 -> F c.l1_move != -1);

-- inner requests are always serviced
LTLSPEC G (lift1.f1.on -> F lift1.resetf1);
LTLSPEC G (lift1.f2.on -> F lift1.resetf2);
LTLSPEC G (lift1.f3.on -> F lift1.resetf3);
LTLSPEC G (lift1.f4.on -> F lift1.resetf4);
LTLSPEC G (lift1.f5.on -> F lift1.resetf5);

-- outer requests are always serviced
LTLSPEC G (c.up1.on -> F c.reset_up1);
LTLSPEC G (c.up2.on -> F c.reset_up2);
LTLSPEC G (c.up3.on -> F c.reset_up3);
LTLSPEC G (c.up4.on -> F c.reset_up4);

LTLSPEC G (c.dn5.on -> F c.reset_dn5);
LTLSPEC G (c.dn4.on -> F c.reset_dn4);
LTLSPEC G (c.dn3.on -> F c.reset_dn3);
LTLSPEC G (c.dn2.on -> F c.reset_dn2);
